<?php

/**
 * @file
 * Use AI to summarize PDF files.
 */

use Aws\Credentials\Credentials;
use Aws\S3\S3Client;
use Aws\Signature\SignatureV4;
use Aws\Textract\TextractClient;
use Drupal\content_moderation\Entity\ContentModerationState;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use GuzzleHttp\Client;
use GuzzleHttp\Psr7\Request;
use Symfony\Component\Process\Process;

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function ocha_ai_summarize_node_insert(EntityInterface $entity) {
  ocha_ai_summarize_node_update($entity);
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function ocha_ai_summarize_node_update(EntityInterface $entity) {
  if ($entity->bundle() !== 'summary') {
    return;
  }

  /** @var \Drupal\content_moderation\ModerationInformationInterface $moderation_info */
  $moderation_info = Drupal::service('content_moderation.moderation_information');

  // Check to see if the content is moderated or not.
  $is_moderated = $moderation_info->isModeratedEntity($entity);

  if (!$is_moderated) {
    return;
  }

  $current_state = $entity->moderation_state->value;
  $automatic_mode = $entity->field_automatic_mode->value;

  if (!$current_state) {
    return;
  }

  $queue_name = '';
  switch ($current_state) {
    case 'pdf_uploaded':
      if ($automatic_mode) {
        $entity->set('moderation_state', 'extract_text');
        $entity->save();
      }
      break;

    case 'extract_text':
      $queue_name = 'ocha_ai_summarize_extract_text';
      break;

    case 'text_extracted':
      if ($automatic_mode) {
        $entity->set('moderation_state', 'summarize');
        $entity->save();
      }
      break;

    case 'summarize':
      $queue_name = 'ocha_ai_summarize_summarize';
      break;
  }

  if (empty($queue_name)) {
    return;
  }

  $queue = \Drupal::service('queue')->get($queue_name);
  $item = new \stdClass();
  $item->nid = $entity->id();
  $item->brain = $entity->get('field_ai_brain')->value;
  $queue->createItem($item);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ocha_ai_summarize_form_node_summary_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  ocha_ai_summarize_form_node_summary_alter($form, $form_state, $form_id);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ocha_ai_summarize_form_node_summary_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  ocha_ai_summarize_form_node_summary_alter($form, $form_state, $form_id);
}

/**
 * Alter summary form based on state.
 */
function ocha_ai_summarize_form_node_summary_alter(&$form, FormStateInterface $form_state, $form_id) {
  if ($form_id === 'node_summary_form') {
    $form['field_pdf_text']['#access'] = FALSE;
    $form['field_summary']['#access'] = FALSE;
    $form['moderation_state']['#access'] = FALSE;
    $form['moderation_state']['widget'][0]['state']['#default_value'] = 'pdf_uploaded';
    return;
  }

  $node = $form_state->getFormObject()->getEntity();
  $current_state = $node->moderation_state->value;
  if (!$current_state) {
    return;
  }

  switch ($current_state) {
    case 'draft':
    case 'pdf_uploaded':
    case 'extract_text':
      $form['field_pdf_text']['#access'] = FALSE;
      $form['field_summary']['#access'] = FALSE;
      $form['moderation_state']['#access'] = FALSE;
      break;

    case 'text_extracted':
      $form['field_summary']['#access'] = FALSE;
      break;

    case 'summarize':
      $form['field_pdf_text']['#disabled'] = TRUE;
      unset($form['field_pdf_text']['widget'][$form['field_pdf_text']['widget']['#max_delta']]);
      unset($form['field_pdf_text']['widget']['add_more']);

      $form['field_summary']['#access'] = FALSE;
      $form['moderation_state']['#access'] = FALSE;
      break;

    case 'summarized':
      $form['field_pdf_text']['#disabled'] = TRUE;
      unset($form['field_pdf_text']['widget'][$form['field_pdf_text']['widget']['#max_delta']]);
      unset($form['field_pdf_text']['widget']['add_more']);

      $form['field_summary']['#disabled'] = TRUE;
      break;

  }
}

/**
 * Implements hook_ENTITY_TYPE_view().
 */
function ocha_ai_summarize_node_view(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) {
  if ($entity->bundle() !== 'summary') {
    return;
  }

  if ($entity->isPublished()) {
    return;
  }

  $content_moderation_state = ContentModerationState::loadFromModeratedEntity($entity);
  if (!$content_moderation_state) {
    $active = 'pdf_uploaded';
  }
  else {
    $active = $content_moderation_state->get('moderation_state')->value;
  }

  $states = [
    'pdf_uploaded' => [
      '#markup' => 'PDF uploaded',
      '#wrapper_attributes' => [
        'class' => [],
      ],
    ],
    'extract_text' => [
      '#markup' => 'Extract text',
      '#wrapper_attributes' => [
        'class' => [],
      ],
    ],
    'text_extracted' => [
      '#markup' => 'Text extracted',
      '#wrapper_attributes' => [
        'class' => [],
      ],
    ],
    'summarize' => [
      '#markup' => 'Summarize',
      '#wrapper_attributes' => [
        'class' => [],
      ],
    ],
    'summarized' => [
      '#markup' => 'Summarized',
      '#wrapper_attributes' => [
        'class' => [],
      ],
    ],
  ];

  $future = FALSE;
  foreach ($states as $key => &$state) {
    if ($key == $active) {
      $state['#wrapper_attributes']['class'] = ['active'];
      $future = TRUE;
    }
    else {
      if (!$future) {
        $state['#wrapper_attributes']['class'] = ['done'];
      }
      else {
        $state['#wrapper_attributes']['class'] = ['to-do'];
      }
    }
  }

  $build['workflow'] = [
    '#theme' => 'item_list',
    '#attributes' => [
      'class' => [
        'workflow-steps',
      ],
    ],
    '#list_type' => 'ol',
    '#items' => array_values($states),
    '#weight' => -100,
  ];
}

/**
 * Get number of pages in a PDF file.
 */
function ocha_ai_summarize_get_num_pages($filename) {
  $command = [
    'pdfinfo',
    $filename,
  ];

  $process = new Process($command);
  $process->setTimeout(10);
  $process->run();
  if (!$process->isSuccessful()) {
    return FALSE;
  }

  $output = trim($process->getOutput(), " \t\n\r\0\x0B\x0C");

  $matches = [];
  preg_match('/Pages:\s+([\d]+)/', $output, $matches);
  return $matches[1];
}

/**
 * Extract text for each page separately.
 */
function ocha_ai_summarize_extract_pages($filename) {
  $pages = [];
  $num_pages = ocha_ai_summarize_get_num_pages($filename);

  foreach (range(1, $num_pages) as $page_num) {
    $command = [
      'pdftotext',
      '-f',
      $page_num,
      '-l',
      $page_num,
      $filename,
      '-',
    ];

    $process = new Process($command);
    $process->setTimeout(10);
    $process->run();
    if (!$process->isSuccessful()) {
      return FALSE;
    }

    $output = trim($process->getOutput(), " \t\n\r\0\x0B\x0C");

    // Remove tabs.
    $text = str_replace(["\t"], '', $output);

    // Keep lists as is.
    $text = str_replace([
      "\n➢",
      "\n▪",
      "\n-",
      "\n*",
      "\no\n",
    ], [
      "||||➢",
      "||||▪",
      "||||-",
      "||||*",
      "||||o ",
    ], $text);

    // Two new lines make a paragraph.
    $text = str_replace("\n\n", '|||', $text);

    // Remove single line feeds.
    $text = str_replace("\n", ' ', $text);

    // Re-add lists.
    $text = str_replace('||||', "\n", $text);

    // Re-add paragraphs.
    $text = str_replace('|||', "\n\n", $text);

    $pages[] = $text;
  }

  return $pages;
}

/**
 * Upload file to S3.
 */
function ocha_ai_summarize_upload_to_s3($file_name) {
  $config = \Drupal::config('ocha_ai_summarize.settings');
  $access_key = $config->get('bedrock_access_key');
  $secret_key = $config->get('bedrock_secret_key');

  $client = new S3Client([
    'credentials' => [
      'key' => $access_key,
      'secret' => $secret_key,
    ],
    'region' => 'us-east-1',
  ]);

  $bucket_name = 'ai-summarize-pdfs';
  $key_name = basename($file_name);

  $client->putObject([
    'Bucket' => $bucket_name,
    'Key' => $key_name,
    'SourceFile' => $file_name,
  ]);
}

/**
 * Extract text using AWS Textract.
 */
function ocha_ai_summarize_texttract($file_name) {
  $config = \Drupal::config('ocha_ai_summarize.settings');
  $access_key = $config->get('bedrock_access_key');
  $secret_key = $config->get('bedrock_secret_key');

  $client = new TextractClient([
    'region' => 'us-east-1',
    'credentials' => [
      'key' => $access_key,
      'secret' => $secret_key,
    ],
  ]);

  $bucket_name = 'ai-summarize-pdfs';
  $key_name = basename($file_name);

  $options = [
    'DocumentLocation' => [
      'S3Object' => [
        'Bucket' => $bucket_name,
        'Name' => $key_name,
      ],
    ],
    'FeatureTypes' => [],
  ];

  $result = $client->startDocumentTextDetection($options);
  $job_id = $result->get('JobId');
  return $job_id;
}

/**
 * Get extracted text using AWS Textract.
 */
function ocha_ai_summarize_texttract_get_text($job_id) {
  $config = \Drupal::config('ocha_ai_summarize.settings');
  $access_key = $config->get('bedrock_access_key');
  $secret_key = $config->get('bedrock_secret_key');

  $client = new TextractClient([
    'region' => 'us-east-1',
    'credentials' => [
      'key' => $access_key,
      'secret' => $secret_key,
    ],
  ]);

  $options = [
    'JobId' => $job_id,
  ];

  $result = $client->GetDocumentTextDetection($options);
  $blocks = $result->get('Blocks');
  $status = $result->get('JobStatus');

  if ($status == 'SUCCEEDED') {
    $output = '';

    // Concatenate.
    foreach ($blocks as $value) {
      if (isset($value['BlockType']) && $value['BlockType']) {
        $blockType = $value['BlockType'];
        if (isset($value['Text']) && $value['Text']) {
          $text = $value['Text'];
          if ($blockType == 'WORD') {
            $output .= ' ' . $text;
          }
          elseif ($blockType == 'LINE') {
            $output .= "\n" . $text;
          }
        }
      }
    }

    $output .= "\n";
    return $output;
  }

  return '';
}

/**
 * Test run for AWS Textract.
 */
function ocha_ai_summarize_testit() {
  $file_name = '/var/www/private_files/2023-09/2018_OCHA_Aide Memoire.pdf';
  ocha_ai_summarize_upload_to_s3($file_name);
  $job_id = ocha_ai_summarize_texttract($file_name);

  sleep(5);

  $text = ocha_ai_summarize_texttract_get_text($job_id);
  return $text;
}

/**
 * Make chat call to OpenAi.
 */
function ocha_ai_summarize_http_call_openai($query) {
  $config = \Drupal::config('ocha_ai_summarize.settings');

  $http_client = \Drupal::httpClient();
  $url = 'https://api.openai.com/v1/chat/completions';

  $headers = [
    'Content-Type' => 'application/json',
    'Authorization' => 'Bearer ' . $config->get('openai_token'),
  ];

  $response = $http_client->request(
    'POST',
    $url,
    [
      'headers' => $headers,
      'json' => $query,
    ],
  );

  $body = $response->getBody() . '';
  return json_decode($body, TRUE);
}

/**
 * Make chat call to Azure.
 */
function ocha_ai_summarize_http_call_azure($query) {
  $config = \Drupal::config('ocha_ai_summarize.settings');
  $endpoint = $config->get('azure_endpoint');
  $key = $config->get('azure_apikey');

  $http_client = \Drupal::httpClient();

  $headers = [
    'Content-Type' => 'application/json',
    'API-KEY' => $key,
  ];

  $response = $http_client->request(
    'POST',
    $endpoint,
    [
      'headers' => $headers,
      'json' => $query,
    ],
  );

  $body = $response->getBody() . '';
  return json_decode($body, TRUE);
}

/**
 * Make chat call to BedRock.
 */
function ocha_ai_summarize_http_call_bedrock($prompt) {
  $config = \Drupal::config('ocha_ai_summarize.settings');
  $endpoint = $config->get('bedrock_endpoint');
  $access_key = $config->get('bedrock_access_key');
  $secret_key = $config->get('bedrock_secret_key');
  $model = $config->get('bedrock_model');

  $headers = [
    'Content-Type' => 'application/json',
    'Accept' => 'application/json',
    'modelId' => $model,
  ];

  $version = '1.1';

  $body = [
    'inputText' => $prompt,
    'textGenerationConfig' => [
      'maxTokenCount' => 4000,
      'stopSequences' => [],
      'temperature' => 0,
      'topP' => 1,
    ],
  ];

  $client = new Client([
    'timeout' => 30,
  ]);

  $request = new Request('POST', $endpoint, $headers, json_encode($body), $version);

  $region = 'us-east-1';
  $service = 'bedrock';
  $signature = new SignatureV4($service, $region);
  $credentials = new Credentials($access_key, $secret_key);

  $request = $signature->signRequest($request, $credentials);
  $response = $client->send($request);

  $body = $response->getBody() . '';
  return json_decode($body, TRUE);
}
